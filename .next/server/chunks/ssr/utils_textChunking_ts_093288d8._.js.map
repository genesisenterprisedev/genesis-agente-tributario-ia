{"version":3,"sources":["../../../../utils/textChunking.ts"],"sourcesContent":["/**\n * Divide um texto em chunks menores com overlap\n * @param text Texto completo para dividir\n * @param maxChunkSize Tamanho máximo de cada chunk em caracteres\n * @param overlap Quantidade de caracteres de sobreposição entre chunks\n * @returns Array de chunks com texto e índice\n */\nexport function chunkText(\n    text: string,\n    maxChunkSize: number = 500,\n    overlap: number = 50\n): { text: string; index: number }[] {\n    if (!text || text.trim().length === 0) {\n        return [];\n    }\n\n    const chunks: { text: string; index: number }[] = [];\n    let index = 0;\n    let position = 0;\n\n    // Limpar texto\n    const cleanText = text.trim();\n\n    while (position < cleanText.length) {\n        // Calcular fim do chunk\n        let end = Math.min(position + maxChunkSize, cleanText.length);\n\n        // Se não for o último chunk, tentar quebrar em uma sentença ou parágrafo\n        if (end < cleanText.length) {\n            // Procurar por quebra de parágrafo\n            const paragraphBreak = cleanText.lastIndexOf('\\n\\n', end);\n            if (paragraphBreak > position) {\n                end = paragraphBreak;\n            } else {\n                // Procurar por fim de sentença\n                const sentenceEnd = cleanText.lastIndexOf('. ', end);\n                if (sentenceEnd > position) {\n                    end = sentenceEnd + 1;\n                }\n            }\n        }\n\n        // Extrair chunk\n        const chunkText = cleanText.slice(position, end).trim();\n\n        // Adicionar chunk se não estiver vazio\n        if (chunkText.length > 0) {\n            chunks.push({\n                text: chunkText,\n                index\n            });\n            index++;\n        }\n\n        // Mover posição com overlap\n        position = end - overlap;\n\n        // Evitar loop infinito\n        if (position <= 0 || position >= cleanText.length) {\n            break;\n        }\n    }\n\n    return chunks;\n}\n\n/**\n * Divide texto em chunks por parágrafos\n * @param text Texto completo\n * @param maxChunkSize Tamanho máximo em caracteres\n * @returns Array de chunks\n */\nexport function chunkByParagraphs(\n    text: string,\n    maxChunkSize: number = 1000\n): { text: string; index: number }[] {\n    const paragraphs = text.split(/\\n\\n+/);\n    const chunks: { text: string; index: number }[] = [];\n    let currentChunk = '';\n    let index = 0;\n\n    for (const paragraph of paragraphs) {\n        const trimmedParagraph = paragraph.trim();\n\n        if (!trimmedParagraph) continue;\n\n        // Se adicionar este parágrafo ultrapassar o limite\n        if (currentChunk.length + trimmedParagraph.length > maxChunkSize) {\n            // Salvar chunk atual se não estiver vazio\n            if (currentChunk.length > 0) {\n                chunks.push({ text: currentChunk.trim(), index });\n                index++;\n                currentChunk = '';\n            }\n\n            // Se o parágrafo sozinho for maior que o limite, dividir\n            if (trimmedParagraph.length > maxChunkSize) {\n                const subChunks = chunkText(trimmedParagraph, maxChunkSize, 50);\n                subChunks.forEach(chunk => {\n                    chunks.push({ text: chunk.text, index });\n                    index++;\n                });\n            } else {\n                currentChunk = trimmedParagraph;\n            }\n        } else {\n            // Adicionar parágrafo ao chunk atual\n            currentChunk += (currentChunk ? '\\n\\n' : '') + trimmedParagraph;\n        }\n    }\n\n    // Adicionar último chunk\n    if (currentChunk.trim().length > 0) {\n        chunks.push({ text: currentChunk.trim(), index });\n    }\n\n    return chunks;\n}\n\n/**\n * Estima o número de tokens em um texto\n * Aproximação: ~4 caracteres por token\n * @param text Texto para estimar\n * @returns Número estimado de tokens\n */\nexport function estimateTokens(text: string): number {\n    return Math.ceil(text.length / 4);\n}\n\n/**\n * Divide texto respeitando limite de tokens\n * @param text Texto completo\n * @param maxTokens Máximo de tokens por chunk\n * @returns Array de chunks\n */\nexport function chunkByTokens(\n    text: string,\n    maxTokens: number = 500\n): { text: string; index: number; estimatedTokens: number }[] {\n    const maxChars = maxTokens * 4; // Aproximação\n    const chunks = chunkText(text, maxChars, 50);\n\n    return chunks.map(chunk => ({\n        ...chunk,\n        estimatedTokens: estimateTokens(chunk.text),\n    }));\n}\n"],"names":[],"mappings":"uCAOO,SAAS,EACZ,CAAY,CACZ,EAAuB,GAAG,CAC1B,EAAkB,EAAE,EAEpB,GAAI,CAAC,GAA+B,GAAG,CAA1B,EAAK,IAAI,GAAG,MAAM,CAC3B,MAAO,EAAE,CAGb,IAAM,EAA4C,EAAE,CAChD,EAAQ,EACR,EAAW,EAGT,EAAY,EAAK,IAAI,GAE3B,KAAO,EAAW,EAAU,MAAM,EAAE,CAEhC,IAAI,EAAM,KAAK,GAAG,CAAC,EAAW,EAAc,EAAU,MAAM,EAG5D,GAAI,EAAM,EAAU,MAAM,CAAE,CAExB,IAAM,EAAiB,EAAU,WAAW,CAAC,OAAQ,GACrD,GAAI,EAAiB,EACjB,EAAM,MACH,AAFwB,CAI3B,IAAM,EAAc,EAAU,WAAW,CAAC,KAAM,GAC5C,EAAc,IACd,EAAM,GAAc,CADI,AAGhC,CACJ,CAGA,IAAM,EAAY,EAAU,KAAK,CAAC,EAAU,GAAK,IAAI,GAerD,GAZI,EAAU,MAAM,CAAG,GAAG,CACtB,EAAO,IAAI,CAAC,CACR,KAAM,EACN,OACJ,GACA,KAOA,CAHJ,EAAW,EAAM,CAAA,GAGD,GAAK,GAAY,EAAU,MAAM,CAC7C,CAD+C,IAGvD,CAEA,OAAO,CACX,CAQO,SAAS,EACZ,CAAY,CACZ,EAAuB,GAAI,EAE3B,IAAM,EAAa,EAAK,KAAK,CAAC,SACxB,EAA4C,EAAE,CAChD,EAAe,GACf,EAAQ,EAEZ,IAAK,IAAM,KAAa,EAAY,CAChC,IAAM,EAAmB,EAAU,IAAI,GAElC,IAGD,EAAa,MAAM,CAAG,EAAiB,GAHpB,GAG0B,CAAG,GAE5C,EAAa,MAAM,CAAG,EAFoC,CAEjC,CACzB,EAAO,IAAI,CAAC,CAAE,KAAM,EAAa,IAAI,SAAI,CAAM,GAC/C,IACA,EAAe,IAIf,EAAiB,MAAM,CAAG,EACR,AAClB,EAD4B,EAAkB,EAAc,IAClD,EAF8B,KAEvB,CAAC,IACd,EAAO,IAAI,CAAC,CAAE,KAAM,EAAM,IAAI,OAAE,CAAM,GACtC,GACJ,GAEA,EAAe,GAInB,GAAgB,CAAC,EAAe,OAAS,EAAA,CAAE,CAAI,EAEvD,CAOA,OAJI,EAAa,IAAI,GAAG,MAAM,CAAG,GAAG,AAChC,EAAO,IAAI,CAAC,CAAE,KAAM,EAAa,IAAI,SAAI,CAAM,GAG5C,CACX,CAQO,SAAS,EAAe,CAAY,EACvC,OAAO,KAAK,IAAI,CAAC,EAAK,MAAM,CAAG,EACnC,CAQO,SAAS,EACZ,CAAY,CACZ,EAAoB,GAAG,EAKvB,OAFe,AAER,EAFkB,EADI,EAAZ,CAAe,CACD,AAAU,IAE3B,GAAG,CAAC,IAAU,CAHkB,AAI1C,GADuB,AACpB,CAAK,CACR,gBAAiB,EAAe,EAAM,IAAI,EAC9C,CAAC,CACL"}