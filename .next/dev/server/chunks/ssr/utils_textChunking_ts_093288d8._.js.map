{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///media/elso/dev/projects/genesisEnterprise/genesis.specific/frontend/genesis-agente-tributario-ia/utils/textChunking.ts"],"sourcesContent":["/**\n * Divide um texto em chunks menores com overlap\n * @param text Texto completo para dividir\n * @param maxChunkSize Tamanho máximo de cada chunk em caracteres\n * @param overlap Quantidade de caracteres de sobreposição entre chunks\n * @returns Array de chunks com texto e índice\n */\nexport function chunkText(\n    text: string,\n    maxChunkSize: number = 500,\n    overlap: number = 50\n): { text: string; index: number }[] {\n    if (!text || text.trim().length === 0) {\n        return [];\n    }\n\n    const chunks: { text: string; index: number }[] = [];\n    let index = 0;\n    let position = 0;\n\n    // Limpar texto\n    const cleanText = text.trim();\n\n    while (position < cleanText.length) {\n        // Calcular fim do chunk\n        let end = Math.min(position + maxChunkSize, cleanText.length);\n\n        // Se não for o último chunk, tentar quebrar em uma sentença ou parágrafo\n        if (end < cleanText.length) {\n            // Procurar por quebra de parágrafo\n            const paragraphBreak = cleanText.lastIndexOf('\\n\\n', end);\n            if (paragraphBreak > position) {\n                end = paragraphBreak;\n            } else {\n                // Procurar por fim de sentença\n                const sentenceEnd = cleanText.lastIndexOf('. ', end);\n                if (sentenceEnd > position) {\n                    end = sentenceEnd + 1;\n                }\n            }\n        }\n\n        // Extrair chunk\n        const chunkText = cleanText.slice(position, end).trim();\n\n        // Adicionar chunk se não estiver vazio\n        if (chunkText.length > 0) {\n            chunks.push({\n                text: chunkText,\n                index\n            });\n            index++;\n        }\n\n        // Mover posição com overlap\n        position = end - overlap;\n\n        // Evitar loop infinito\n        if (position <= 0 || position >= cleanText.length) {\n            break;\n        }\n    }\n\n    return chunks;\n}\n\n/**\n * Divide texto em chunks por parágrafos\n * @param text Texto completo\n * @param maxChunkSize Tamanho máximo em caracteres\n * @returns Array de chunks\n */\nexport function chunkByParagraphs(\n    text: string,\n    maxChunkSize: number = 1000\n): { text: string; index: number }[] {\n    const paragraphs = text.split(/\\n\\n+/);\n    const chunks: { text: string; index: number }[] = [];\n    let currentChunk = '';\n    let index = 0;\n\n    for (const paragraph of paragraphs) {\n        const trimmedParagraph = paragraph.trim();\n\n        if (!trimmedParagraph) continue;\n\n        // Se adicionar este parágrafo ultrapassar o limite\n        if (currentChunk.length + trimmedParagraph.length > maxChunkSize) {\n            // Salvar chunk atual se não estiver vazio\n            if (currentChunk.length > 0) {\n                chunks.push({ text: currentChunk.trim(), index });\n                index++;\n                currentChunk = '';\n            }\n\n            // Se o parágrafo sozinho for maior que o limite, dividir\n            if (trimmedParagraph.length > maxChunkSize) {\n                const subChunks = chunkText(trimmedParagraph, maxChunkSize, 50);\n                subChunks.forEach(chunk => {\n                    chunks.push({ text: chunk.text, index });\n                    index++;\n                });\n            } else {\n                currentChunk = trimmedParagraph;\n            }\n        } else {\n            // Adicionar parágrafo ao chunk atual\n            currentChunk += (currentChunk ? '\\n\\n' : '') + trimmedParagraph;\n        }\n    }\n\n    // Adicionar último chunk\n    if (currentChunk.trim().length > 0) {\n        chunks.push({ text: currentChunk.trim(), index });\n    }\n\n    return chunks;\n}\n\n/**\n * Estima o número de tokens em um texto\n * Aproximação: ~4 caracteres por token\n * @param text Texto para estimar\n * @returns Número estimado de tokens\n */\nexport function estimateTokens(text: string): number {\n    return Math.ceil(text.length / 4);\n}\n\n/**\n * Divide texto respeitando limite de tokens\n * @param text Texto completo\n * @param maxTokens Máximo de tokens por chunk\n * @returns Array de chunks\n */\nexport function chunkByTokens(\n    text: string,\n    maxTokens: number = 500\n): { text: string; index: number; estimatedTokens: number }[] {\n    const maxChars = maxTokens * 4; // Aproximação\n    const chunks = chunkText(text, maxChars, 50);\n\n    return chunks.map(chunk => ({\n        ...chunk,\n        estimatedTokens: estimateTokens(chunk.text),\n    }));\n}\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;;;;;;;AACM,SAAS,UACZ,IAAY,EACZ,eAAuB,GAAG,EAC1B,UAAkB,EAAE;IAEpB,IAAI,CAAC,QAAQ,KAAK,IAAI,GAAG,MAAM,KAAK,GAAG;QACnC,OAAO,EAAE;IACb;IAEA,MAAM,SAA4C,EAAE;IACpD,IAAI,QAAQ;IACZ,IAAI,WAAW;IAEf,eAAe;IACf,MAAM,YAAY,KAAK,IAAI;IAE3B,MAAO,WAAW,UAAU,MAAM,CAAE;QAChC,wBAAwB;QACxB,IAAI,MAAM,KAAK,GAAG,CAAC,WAAW,cAAc,UAAU,MAAM;QAE5D,yEAAyE;QACzE,IAAI,MAAM,UAAU,MAAM,EAAE;YACxB,mCAAmC;YACnC,MAAM,iBAAiB,UAAU,WAAW,CAAC,QAAQ;YACrD,IAAI,iBAAiB,UAAU;gBAC3B,MAAM;YACV,OAAO;gBACH,+BAA+B;gBAC/B,MAAM,cAAc,UAAU,WAAW,CAAC,MAAM;gBAChD,IAAI,cAAc,UAAU;oBACxB,MAAM,cAAc;gBACxB;YACJ;QACJ;QAEA,gBAAgB;QAChB,MAAM,YAAY,UAAU,KAAK,CAAC,UAAU,KAAK,IAAI;QAErD,uCAAuC;QACvC,IAAI,UAAU,MAAM,GAAG,GAAG;YACtB,OAAO,IAAI,CAAC;gBACR,MAAM;gBACN;YACJ;YACA;QACJ;QAEA,4BAA4B;QAC5B,WAAW,MAAM;QAEjB,uBAAuB;QACvB,IAAI,YAAY,KAAK,YAAY,UAAU,MAAM,EAAE;YAC/C;QACJ;IACJ;IAEA,OAAO;AACX;AAQO,SAAS,kBACZ,IAAY,EACZ,eAAuB,IAAI;IAE3B,MAAM,aAAa,KAAK,KAAK,CAAC;IAC9B,MAAM,SAA4C,EAAE;IACpD,IAAI,eAAe;IACnB,IAAI,QAAQ;IAEZ,KAAK,MAAM,aAAa,WAAY;QAChC,MAAM,mBAAmB,UAAU,IAAI;QAEvC,IAAI,CAAC,kBAAkB;QAEvB,mDAAmD;QACnD,IAAI,aAAa,MAAM,GAAG,iBAAiB,MAAM,GAAG,cAAc;YAC9D,0CAA0C;YAC1C,IAAI,aAAa,MAAM,GAAG,GAAG;gBACzB,OAAO,IAAI,CAAC;oBAAE,MAAM,aAAa,IAAI;oBAAI;gBAAM;gBAC/C;gBACA,eAAe;YACnB;YAEA,yDAAyD;YACzD,IAAI,iBAAiB,MAAM,GAAG,cAAc;gBACxC,MAAM,YAAY,UAAU,kBAAkB,cAAc;gBAC5D,UAAU,OAAO,CAAC,CAAA;oBACd,OAAO,IAAI,CAAC;wBAAE,MAAM,MAAM,IAAI;wBAAE;oBAAM;oBACtC;gBACJ;YACJ,OAAO;gBACH,eAAe;YACnB;QACJ,OAAO;YACH,qCAAqC;YACrC,gBAAgB,CAAC,eAAe,SAAS,EAAE,IAAI;QACnD;IACJ;IAEA,yBAAyB;IACzB,IAAI,aAAa,IAAI,GAAG,MAAM,GAAG,GAAG;QAChC,OAAO,IAAI,CAAC;YAAE,MAAM,aAAa,IAAI;YAAI;QAAM;IACnD;IAEA,OAAO;AACX;AAQO,SAAS,eAAe,IAAY;IACvC,OAAO,KAAK,IAAI,CAAC,KAAK,MAAM,GAAG;AACnC;AAQO,SAAS,cACZ,IAAY,EACZ,YAAoB,GAAG;IAEvB,MAAM,WAAW,YAAY,GAAG,cAAc;IAC9C,MAAM,SAAS,UAAU,MAAM,UAAU;IAEzC,OAAO,OAAO,GAAG,CAAC,CAAA,QAAS,CAAC;YACxB,GAAG,KAAK;YACR,iBAAiB,eAAe,MAAM,IAAI;QAC9C,CAAC;AACL"}}]
}